#!/bin/bash
DEV=/dev/dvd
VERBOSE=1
CLEANUP=1

echo_status()
{
   level=$1 && shift
   if [ "$VERBOSE" -ge $level ]; then
      echo "$@" >&2
   fi
}
echo_info() { echo_status 1 "$@"; }
echo_debug() { echo_status 2 "$@"; }

exit_fail()
{
   echo "$@" >&2
   exit 1
}

echo_info "Checking device access for $DEV ..."
test -r $DEV || exit_fail "Can't access device $DEV"

echo_info "Reading Volume name of disc in $DEV ..."
vol_name="`/sbin/blkid -s LABEL -o value $DEV`" || exit_fail "Can't read volume name of disc in $DEV"
echo_info "Volume name: $vol_name"

echo_info "Extracting decrypted DVD contents from $DEV into temporary directory $vol_name using dvdbackup ..."
(
   if [ "$VERBOSE" -ge 1 ]; then
      dvdbackup_verbose="-p"
   else
      exec 2>/dev/null
   fi
   dvdbackup -i $DEV -M -n $vol_name $dvdbackup_verbose || exit 1
) || exit_fail "Failed extracting decrypted DVD contents from $DEV with dvdbackup"
echo_info
echo_info "Finished extracting decrypted DVD contents into $vol_name"
cd "$vol_name" || exit_fail "Failed opening temporary directory $vol_name"

iso_name="$vol_name".iso
echo_info "Compiling worklist for assembling purified image file ..."

echo_debug "Compiling decrypted video items:"
for file in */*.VOB; do
   echo_debug "   $file ..."

   item_size=`stat --printf '%s' $file` || exit_fail "Failed preparing worklist item for file $file"
   echo_debug "      Decrypted size: $item_size"

   item_offset_blocks=`udffindfile /$file $item_size` || exit_fail "Failed preparing worklist item for file $file"
   item_offset=$(( $item_offset_blocks * 2048 ))
   echo_debug "      Offset in image: $item_offset"

   item_after=$(( $item_offset + $item_size ))
   echo_debug "      Offset after item: $item_after"

   worklist+=`echo "$item_offset $item_after $file"`$'\n'
done

echo_debug "Compiling region code removal items:"
for file in VIDEO_TS/VIDEO_TS.{IFO,BUP}; do
   echo_debug "   $file ..."

   expected_size=`stat --printf '%s' $file` || exit_fail "Failed preparing worklist item for file $file"
   echo_debug "      Expected size (in bytes): $expected_size"

   file_offset=`udffindfile /$file $expected_size` || exit_fail "Failed preparing worklist item for file $file"
   echo_debug "      File offset in image (in 2 KiB blocks): $file_offset"

   item_offset=$(( $file_offset * 2048 + 35 ))
   echo_debug "      Region code field offset in image (in bytes): $item_offset"

   item_after=$(( $item_offset + 1 ))
   echo_debug "      Offset after item: $item_after"

   worklist+=`echo "$item_offset $item_after /dev/zero"`$'\n'
done

worklist=`echo "$worklist"` # Drop the trailing \n
echo_debug
echo_debug "Unordered worklist:"
echo_debug "$worklist"

worklist=`<<<"$worklist" sort -n`
echo_debug
echo_debug "Ordered worklist:"
echo_debug "$worklist"

# Amend worklist with fragments to copy unaltered from original DVD.
# (Everything around/between the specially handled fragments we already have in the worklist.)
#
# Before every existing worklist entry, we put an extra fragment
# spanning from the end of the previous entry (or from 0 for the first one) to the beginning of the current entry.
# Finally, we put another fragment at the very end,
# spanning from the end of the last existing worklist entry to the end of the disk.
#
# All these added fragments use the DVD device as source.
worklist=`<<<"$worklist" sed '
   # Initialise loop: put "0" into hold space,
   # so for the first input line,
   # 0 is presented as the end of the preceding fragment.
   #
   # Pattern space is restored to original state before entering first main loop iteration,

   1{
      h        # hold_space = pattern_space = "<current_start> <current_end> <source>"
      s%.*%0%  # pattern_space = "0"
      x        # pattern_space = "<current_start> <current_end> <source>"; hold_space = "0"
   }

   # Main loop: for every input line,
   # first create a fragment spanning from end address of previous fragment (from hold space)
   # to start address of the one in the input line,
   # to copy unaltered part from original DVD,
   # and print it explicitly;
   # then save the end address of the fragment from the input line to the hold space.
   #
   # The pattern space is restored to the original input line afterwards,
   # and will get printed automatically by sed.

   x                                          # pattern_space = "<previous_end>"; hold_space = "<current_start> <current_end> <source>"
   G                                          # pattern_space = "<previous_end>\n<current_start> <current_end> <source>"
   s%\([^\n]*\)\n\([^ ]*\).*%\1 \2 '"$DEV"'%  # pattern_space = "<previous_end> <current_start> <DEV>"
   /^\([^ ]*\) \1/!p                          # if !(current_start == previous_end) print pattern_space ("<previous_end> <current_start> <DEV>")
   g                                          # pattern_space = hold_space = "<current_start> <current_end> <source>"
   s%[^ ]* \([^ ]*\).*%\1%                    # pattern_space = "<current_end>"
   x                                          # hold_space = "<current_end>"; pattern_space = "<current_start> <current_end> <source> "

   # Final iteration: first print the current input line;
   # and then generate a fragment spanning from end of the input line
   # to the end of the disc (indicated by "-"),
   # to copy remaining part of original DVD.
   #
   # That final fragment will be printed automatically by sed.

   ${
      p                 # print pattern_space ("<current_start> <current_end> <source>")
      g                 # pattern_space = "<previous_end>"
      s%$% - '"$DEV"'%  # pattern_space = "<previous_end> - <DEV>"
   }
'` || exit_fail "Failed preparing worklist"
echo_debug
echo_debug "Complete worklist:"
echo_debug "$worklist"
echo_debug


echo_info "Assembling purified image file in $iso_name from decrypted files and unaltered fragments..."
exec <<<"$worklist"
while read start end source; do
   if [ "$end" != "-" ]; then
      size=$(( $end - $start ))
   else
      size=
   fi

   if [ "$source" = "$DEV" ]; then
      if [ -n "$size" ]; then
         echo_debug "   Copying original data from $source: start=$start end=$end (size=$size) ..."
         dd if="$source" iflag=skip_bytes,count_bytes skip=$start count=$size status=none | pv -N "   $source" -s $size >>../"$iso_name" || exit_fail "Failed copying data from $source: start=$start size=$size"
      else
         echo_debug "   Copying original data from $source: start=$start (until end) ..."
         dd if="$source" iflag=skip_bytes skip=$start status=none | pv -N "   $source" >>../"$iso_name" || exit_fail "Failed copying data from $source: start=$start (until end)"
      fi
   else
      echo_debug "   Copying substitute data from $source: start=$start end=$end (size=$size) ..."
      pv "$source" -N "   $source" -s $size -S >>../"$iso_name" || exit_fail "Failed copying data from $source: start=$start size=$size"
   fi

   test -z "$size" || test "`stat --printf '%s' ../$iso_name`" -eq $end || exit_fail "Failed copying data from $source: $iso_name doesn't have expected size $end after operation"
done

if [ "$CLEANUP" -eq 1 ]; then
   echo_info "Cleaning up temporary directory ..."
   cd .. && rm -r "$vol_name"
fi

echo_info
echo_info "Success: $iso_name should now contain an unencrypted, region-free image."
echo_info "You can write it to a blank medium using for instance \"cdrskin $iso_name\"."
